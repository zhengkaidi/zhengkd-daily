<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>RegExp篇一 | Hello zkd</title>
    <meta name="description" content="今天也要加油哦">
    <link rel="icon" href="/logo.jpg">
    
    <link rel="preload" href="/assets/css/0.styles.bd479351.css" as="style"><link rel="preload" href="/assets/js/app.a2351635.js" as="script"><link rel="preload" href="/assets/js/2.b3d03c0f.js" as="script"><link rel="preload" href="/assets/js/10.386adb92.js" as="script"><link rel="prefetch" href="/assets/js/11.cca97503.js"><link rel="prefetch" href="/assets/js/12.8e96d8c2.js"><link rel="prefetch" href="/assets/js/13.c3eaf821.js"><link rel="prefetch" href="/assets/js/14.b7946342.js"><link rel="prefetch" href="/assets/js/15.49eb6595.js"><link rel="prefetch" href="/assets/js/3.b4ff24da.js"><link rel="prefetch" href="/assets/js/4.9278f3e5.js"><link rel="prefetch" href="/assets/js/5.91971827.js"><link rel="prefetch" href="/assets/js/6.44ddbf53.js"><link rel="prefetch" href="/assets/js/7.97633105.js"><link rel="prefetch" href="/assets/js/8.d016392b.js"><link rel="prefetch" href="/assets/js/9.b2a6fb1b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bd479351.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Hello zkd</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">主页</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">主页</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>入门</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/guide/install/test.html" class="sidebar-link">前言</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="regexp篇一"><a href="#regexp篇一" class="header-anchor">#</a> RegExp篇一</h1> <h2 id="前言："><a href="#前言：" class="header-anchor">#</a> 前言：</h2> <p><strong>对于正则表达式，相信很多人都知道，但是很多人的第一感觉就是难学，因为看第一眼时，觉得完全没有规律可寻，而且全是一堆各种各样的特殊符号，完全不知所云。
其实只是对正则不了解而以，了解了你就会发现，原来就这样啊正则所用的相关字符其实不多，也不难记，更不难懂，唯一难的就是组合起来之后，可读性比较差，而且不容易理解，本文旨在让大家对正则有一个基本的了解，能看得懂简单的正则表达式，写得出简单的正则表达式，用以满足日常开发中的需求即可。</strong></p> <h3 id="创建一个regexp的两种方式："><a href="#创建一个regexp的两种方式：" class="header-anchor">#</a> 创建一个Regexp的两种方式：<br></h3> <ol><li><code>var reg = /regexp/</code> <br></li> <li><code>var reg = new RegExp('regexp')</code> <br></li> <li>可以配合使用的3个标志：<br></li></ol> <ul><li>i ： i可以使正则表达式在匹配时忽略大小写。<code>/regexp/i</code></li> <li>g ： g标志可以使正则表达式匹配模式的所有实例。</li> <li>m ： 可以使正则表达式跨多行(例如textarea元素的值)进行匹配。
以上这些标志都要放在表达式的尾部（<code>/regexp/ig</code>），或者作为第二个参数传进去（<code>new RegExp('regexp', 'ig')</code>）。</li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>//下面的例子演示了各种标志的用法，以及它们是如何影响模式匹配的:

var pattern = /orange/; 
console.log(pattern.test(&quot;orange&quot;)); // true

var patternIgnoreCase = /orange/i;
console.log(patternIgnoreCase.test(&quot;Orange&quot;)); // true

var patternGlobal = /orange/ig;
console.log(patternGlobal.test(&quot;Orange Juice&quot;)); // true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="严格匹配模式"><a href="#严格匹配模式" class="header-anchor">#</a> 严格匹配模式</h3> <p>任何非正则表达式字符或操作符的字符序列，代表的都是该字符本身:<br> <code>var parttern = /orange/;</code><br>
我们很少采用严格匹配，因为这和直接比较两个字符串没什么分别。严格匹配有时候也 叫作简化模式(simple pattern)。</p> <h3 id="匹配字符组"><a href="#匹配字符组" class="header-anchor">#</a> 匹配字符组</h3> <p>如果想匹配一组字符，可以放到[]中来。例如[abc]就表示a,b,c中的任意一个字符。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var pattern = /[abc]/;
console.log(pattern.test('a')); //true
console.log(pattern.test('d')); //false
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>也可以在模式开头加一个^（脱字符）来表示不想匹配到的内容。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var pattern = /[^abc]/;
console.log(pattern.test('a')); //false
console.log(pattern.test('d')); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这种模式还有另一种很重要的用法是用来指明值的范围。如果想匹配字符或数字的某个连续 范围，可以使用下面的模式:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var pattern = /[0-5]/;
console.log(pattern.test(3)); //true 
console.log(pattern.test(12345)); //true 
console.log(pattern.test(9)); //false 
console.log(pattern.test(6789)); //false 
console.log(/[0123456789]/.test(&quot;This is year 2015&quot;)); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>我们可以看到：[ , ] , ^ , $ , .等字符都是具有特殊含义的字符。那要配配它们的字面量的含义，要怎么做？<br>
加一个<code>\（反斜线字符)</code>就好了。[ 匹配的就是一个普通的字符[, 而不是字符组的开括号。双<code>\\</code>表示一个普通的字符 \ 。</p> <h2 id="补充：-的两种含义："><a href="#补充：-的两种含义：" class="header-anchor">#</a> 补充：^的两种含义：</h2> <p><img src="https://i.loli.net/2019/06/24/5d109d215988c39469.png" alt=""></p> <h2 id="可以运用到开发中的：exec-和-match-和-replace-方法"><a href="#可以运用到开发中的：exec-和-match-和-replace-方法" class="header-anchor">#</a> 可以运用到开发中的：exec() 和 match() 和 replace()方法</h2> <ol><li>在正则中有exec()方法,如下示例：</li></ol> <p><img src="https://i.loli.net/2019/06/24/5d1084c80711c50480.png" alt=""></p> <ol start="2"><li>String对象的方法中有match()方法,如下示例：</li></ol> <p><img src="https://i.loli.net/2019/06/24/5d10854b03dc329442.png" alt=""></p> <p>可以看到两种方法结果是一致的。查找不到的时候则返回null。</p> <ol start="3"><li>String对象的方法replace()方法实现字符的替换：</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>var strToMatch = 'Blue is your favorite color ? blue?'; 
var regExAt = /Blue/ig; 
console.log(strToMatch.replace(regExAt, &quot;Red&quot;));
//输出：Red is your favorite color ? Red?
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>或者，第二个参数接受一个函数：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var strToMatch = 'Blue is your favorite color ?';
var regExAt = /Blue/;
console.log(strToMatch.replace(regExAt, function(matchingText){
  return 'Red';
}));
// 输出&quot;Red is your favorite color ?&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ol start="4"><li>String对象的split()方法也可以接受正则表达式作为参数并返回一个数组，该数组中包含
了经过分割后的所有子串:</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>var sColor = 'sun,moon,Stars';
var reComma = /[n,s]/i; 
console.log(sColor.split(reComma));
//输出: [&quot;&quot;, &quot;u&quot;, &quot;&quot;, &quot;moo&quot;, &quot;&quot;, &quot;&quot;, &quot;tar&quot;, &quot;&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ol start="5"><li>使用简单字符组就可以匹配多个模式。假如想匹配cat、bat和fat，下面的代码片段展示了 具体的做法:</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>var strToMatch = 'wooden bat, smelly Cat,a fat cat';
var re = /[bcf]at/gi;
var arrMatches = strToMatch.match(re);
console.log(arrMatches);
//输出：[&quot;bat&quot;, &quot;Cat&quot;, &quot;fat&quot;, &quot;cat&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="6"><li>如你所见，这种用法可以写出更简洁的正则表达式。来看下面的例子:</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>var strToMatch = 'i1,i2,i3,i4,i5,i6,i7,i8,i9';
var re = /i[0-5]/gi;
var arrMatches = strToMatch.match(re);
console.log(arrMatches);
//输出：[&quot;i1&quot;, &quot;i2&quot;, &quot;i3&quot;, &quot;i4&quot;, &quot;i5&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="快捷写法："><a href="#快捷写法：" class="header-anchor">#</a> 快捷写法：</h2> <table><thead><tr><th>写法</th> <th>含义</th></tr></thead> <tbody><tr><td>\d</td> <td>任意的单个数字字符</td></tr> <tr><td>\w</td> <td>任意的单个字母或数字字符（包括下划线）</td></tr> <tr><td>\s</td> <td>任意的单个空白字符(空格、制表符、换行符等)</td></tr> <tr><td>\D</td> <td>任意的单个非数字字符</td></tr> <tr><td>\W</td> <td>任意的单个非字母或数字字符</td></tr> <tr><td>\s</td> <td>任意的单个非空白字符</td></tr> <tr><td>.</td> <td>除换行符之外的任意单个字符</td></tr></tbody></table> <ol><li>这些快捷写法是书写简洁的正则表达式的关键。看下面的例子:</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>var strToMatch = '123-456-7890';
var re = /\d\d\d-\d\d\d/;
var arrMatches = strToMatch.match(re);
console.log(arrMatches);
//[&quot;123-456&quot;]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ol start="2"><li>解决重复出现的重复限定符：</li></ol> <table><thead><tr><th>写法</th> <th>含义</th></tr></thead> <tbody><tr><td>?</td> <td>出现0次或1次(将模式视为可选的)</td></tr> <tr><td>*</td> <td>出现0次或多次</td></tr> <tr><td>+</td> <td>出现1次或多次</td></tr> <tr><td>{n}</td> <td>只出现n次</td></tr> <tr><td>{n,m}</td> <td>出现n到m次</td></tr> <tr><td>{n, }</td> <td>至少出现n次</td></tr> <tr><td>{ ,n}</td> <td>出现0到n次</td></tr></tbody></table> <ol start="3"><li>\b（边界匹配符）的用法：一边是单词字符(字母、数字或下划线)，另一边是 非单词字符。<br>
下面的例子是一个简单的字面匹配。如果cat是一个子串的话，也能够成功匹配:</li></ol> <div class="language- line-numbers-mode"><pre class="language-text"><code>//非子串：
console.log(/cat/.test('a black cat')); //true

//子串：
console.log(/cat/.test('a blackcat')); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>下面是使用了 <code>\b</code> 以后的例子：</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>//非子串：
console.log(/\bcat/.test('a black cat')); //true

//子串：
console.log(/\bcat/.test('a blackcat')); //false
console.log(/\bcat/.test('a cataa')); //true
console.log(/\bcat\b/.test('a blackcat')); //false
console.log(/\bcat\b/.test('a cat')); //true
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>** \b 作用：**
上面的解释还是有点模糊，\b表示的是字符与字符之间看不见的东西（空格）。
<br>如果想匹配cat字符串的话，需要写成：<code>/\bcat\b/</code> <br>详细解释看下图：</p> <p><img src="https://i.loli.net/2019/06/25/5d11925d66e4080215.png" alt=""></p> <p><strong>exec的用法：</strong> <br>
exec()方法在获取匹配信息方面很有用，因为它会返回一个包含匹配信息的对象。exec() 返回的对象有一个index属性，可以告诉我们成功匹配出现在字符串中的哪个位置。这个功能在 不少地方都能派上用场:</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var match = /\d+/.exec(&quot;There are 100 ways to do this&quot;);
    console.log(match);
    // [&quot;100&quot;]
    console.log(match.index);
// 10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><strong>()组合符的用法：</strong><br>
选择结构可以使用|(管道符)来表示。例如，/a|b/可以匹配字符a或b，/(ab)+|(cd)+/ 可以匹配一个或多个ab或cd。</p> <h2 id="首部-与尾部"><a href="#首部-与尾部" class="header-anchor">#</a> 首部(^)与尾部($)</h2> <p>我们经常需要确保模式在字符串的首部或尾部进行匹配。当脱字符(^)用作正则表达式的 第一个字符的时候，可以将匹配过程锁定在字符串的开头，因此，/^test/只能够匹配出现在待 匹配字符串起始位置上的test子串。与此类似，美元符号($)表示模式必须出现在字符串的尾部: /test$/。<br>
^和$配合使用，表明指定的模式必须涵盖整个待匹配的字符串:/^test$/。</p> <h2 id="向后引用"><a href="#向后引用" class="header-anchor">#</a> 向后引用</h2> <p>在字符串String使用replace()方法时，可以使用特殊的字符序列$1,$2...来表示对应的分组。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>var orig = &quot;1234 5678&quot;;
var re = /(\d{4}) (\d{4})/;
var modifiedStr = orig.replace(re, &quot;$2 $1&quot;); 
console.log(modifiedStr); // 输出&quot;5678 1234&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="贪婪限定符-所有限定符-与-惰性限定符"><a href="#贪婪限定符-所有限定符-与-惰性限定符" class="header-anchor">#</a> 贪婪限定符(所有限定符) 与 惰性限定符(?)</h2> <p>例如，模式\d+能够匹配一个或多个数字。如果字符串是123的话，贪婪匹配可以匹配到1、 12和123。贪婪模式h.+1可以匹配字符串hello中的hell——这是能够匹配的最长的字符串。 因为\d+是贪婪匹配，所以它会尽可能多地匹配数字，故最后的匹配结果就是123。<br>
与贪婪限定符相反，惰性限定符则是尽可能少地匹配字符。可以在正则表达式后面加上问号 (?)，使其成为惰性匹配。惰性模式h.?l可以匹配字符串hello中的hel—— 这是能够匹配到的最短的字符串。<br>
模式\w*?X可以匹配到0个或多个单词以及一个X。但是<code>*</code>后的?表示应该尽可能少地匹配字 符。对于字符串abcXXX，匹配结果可以是abcX、abcXX或abcXXX，那究竟应该匹配哪一个呢? 因为*?是惰性模式，所以应该尽可能少地匹配，因此最后的匹配结果是abcX。<br>
删除字符串首尾多余的空白字符是一个极其常见的用法。直到最近，String对象本身都没有 trim()方法，一些JavaScript库为没有String.trim()方法的旧浏览器提供了字符串修剪功能。 最常用的方法如下所示:<br></p> <div class="language- line-numbers-mode"><pre class="language-text"><code>function trim(str) {
   return (str || &quot;&quot;).replace(/^\s+|\s+$/g,&quot;&quot;);
}
console.log(&quot;--&quot;+trim(&quot;   test   &quot;)+&quot;--&quot;);
//&quot;--test--&quot;

//如果我们想把重复的空白字符替换成单个呢?

 re=/\s+/g;
 console.log('There are     a lot        of spaces'.replace(re,' '));
 //&quot;There are a lot of spaces&quot;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在上面的代码片段中，我们尝试匹配一个或多个空格字符序列，然后将其替换成单个空格。<br>
如你所见，正则表达式就像是JavaScript兵器库中的一把瑞士军刀。从长远来看，细心学习、 充分实践，将为你带来丰厚的长期回报。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">10/17/2019, 7:18:11 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a2351635.js" defer></script><script src="/assets/js/2.b3d03c0f.js" defer></script><script src="/assets/js/10.386adb92.js" defer></script>
  </body>
</html>
